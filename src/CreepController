/*var MyCreep = {
    var buildThreshold = 199;
    var creepMemory:CreepMemory;
    var routine:Function[];
    var energyDestinations:Structure[];
    
    run: function(creep:Creep, energySources?:Structure[]) {
        if (energySources) {
            this.energySources = energySources;
        }
        if (_.isObject(creep)) {
            this.creepMemory = creep.memory;
        }
    }
    
    harvest: function(creep) {
        
    }
    
    action: function (creep) {
        switch{
            case 
        }
    }
    
    getEnergyFromClosestSource: function() {
        let closestEnergySrc:Structure = this.creep.pos.findClosestByRange(this.energySources);
        
        if (closestEnergySrc) {
            return this.getEnergy(closestEnergySrc);
        }
        
        return ERR_NOT_FOUND;
    }
    
    getEnergy: function(source:Structure|Creep) {
        if (this.creep.pos.isNearTo(source) === false) {
            this.creep.moveTo(source);
        }
        if ( (<Structure>source).structureType === STRUCTURE_STORAGE || (<Structure>source).STRUCTURE_TERMINAL) {
            return (<any>source).transfer(this.creep, RESOURCE_ENERGY);
        } else {
            return (<any>source).transferEnergy(this.creep);
        }
    }
    
    storeEnergy: function(dest:Structure|Creep) {
        if (this.creep.pos.isNearTo(dest) === false) {
            return this.creep.moveTo(dest);
        }
        return this.creep.tranfer(dest, RESOURCE_ENERGY);
    }
    
    doOrMoveTo: function(action:Function, target:Structure|Creep|ConstructionSite|Source, distance?:number) {
        if (!distance) {
            distance = 1
        }
        let rangeToTarget = this.creep.pos.getRangeTo(target);
        
        if (rangeToTarget <= distance) {
            return action.call(this.creep, target);
        }
        
        return this.creep.moveTo(target);
    }
    
    findClosestByRange: function(findConstant:number, filterFunction?:Function) {
        if (filterFunction) {
            return this.creep.pos.findClosestByRange<T>(findConstant, {
                filter: filterFunction
            });
        }
        return this.creep.pos.findClosestByRange<T>(findConstant);
    }
    
    findAllInTheRoom: function(findConstant:number, filterFunction?:Function) {
        if (filterFunction) {
            return this.creep.room.find<T>(findConstant, {
                filter: filterFunction
            });
        }
        return this.creep.room.find<T>(findConstant);
    }
}

module.exports = MyCreep;

var roleHarvester = {

    run: function(creep) {
        if(!creep.memory.harvesting && creep.carry.energy < 1) {
            creep.memory.harvesting = true;
            creep.say('harvesting');
	    }
	    else if (creep.memory.harvesting && creep.carry.energy == creep.carryCapacity){
	        creep.memory.harvesting = false;
	        creep.say('dumping');
	    }
        
        if(creep.memory.harvesting) {
	        var sources = creep.room.find(FIND_SOURCES);
            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {
                creep.moveTo(sources[0]);
            }
	    }
	    else {
	        if (creep.transfer(Game.spawns['ADC_Awesome1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE){
                creep.moveTo(Game.spawns['ADC_Awesome1']);
            }
	    }
    }
};

module.exports = roleHarvester;*/
